#!/usr/bin/with-contenv bashio
# shellcheck shell=bash

WEBUI_PORT=${WEBUI_PORT:-8080}
export PATH="/usr/local/sbin:/usr/local/bin:${PATH}"

# --- Configuration & Pre-checks ---

if bashio::config.true 'silent'; then
    sed -i 's|/proc/1/fd/1 hassio;|off;|g' /etc/nginx/nginx.conf
fi

# --- WireGuard Specific Logic ---

_setup_wireguard() {
    local WIREGUARD_STATE_DIR="/var/run/wireguard"
    local output=""
    local status=0

    if ! bashio::fs.file_exists "${WIREGUARD_STATE_DIR}/config"; then
        bashio::exit.nok 'WireGuard runtime configuration not prepared. Please restart the add-on.'
    fi

    local wireguard_config
    wireguard_config="$(cat "${WIREGUARD_STATE_DIR}/config")"
    local wireguard_interface
    wireguard_interface="$(cat "${WIREGUARD_STATE_DIR}/interface" 2>/dev/null || echo 'wg0')"

    if ip link show "${wireguard_interface}" >/dev/null 2>&1; then
        bashio::log.warning "WireGuard interface ${wireguard_interface} already exists. Resetting."
        wg-quick down "${wireguard_config}" >/dev/null 2>&1 || true
    fi

    bashio::log.info "Starting WireGuard interface ${wireguard_interface}..."

    # Internal helper: fallback for iptables-legacy
    _wg_prepare_legacy() {
        local legacy_bin_dir="${WIREGUARD_STATE_DIR}/iptables-legacy-bin"
        mkdir -p "${legacy_bin_dir}"
        local cmd
        for cmd in iptables iptables-save iptables-restore ip6tables ip6tables-save ip6tables-restore; do
            if command -v "${cmd}-legacy" >/dev/null 2>&1; then
                ln -sf "$(command -v "${cmd}-legacy")" "${legacy_bin_dir}/${cmd}"
            fi
        done
        chmod 700 "${legacy_bin_dir}" 2>/dev/null || true
        export PATH="${legacy_bin_dir}:${PATH}"
        bashio::log.warning 'Retrying WireGuard using iptables-legacy wrappers.'
    }

    # Internal helper: Attempt connection
    _wg_up_attempt() {
        local config_path="$1"
        output="$(wg-quick up "${config_path}" 2>&1)" || status=$?

        if [ "${status}" -eq 0 ]; then return 0; fi

        # Allow sysctl failures on read-only hosts while keeping the interface up
        if echo "${output}" | grep -qi 'net\.ipv4\.conf\.all\.src_valid_mark=1'; then
            if echo "${output}" | grep -qiE 'read-only file system|operation not permitted|permission denied'; then
                if ip link show "${wireguard_interface}" >/dev/null 2>&1; then
                    bashio::log.warning 'WireGuard applied but sysctl net.ipv4.conf.all.src_valid_mark=1 could not be set (permission denied). Continuing.'
                    status=0
                    return 0
                fi
            fi
        fi

        # Handle sysctl permission denied errors specifically
        if echo "${output}" | grep -qi 'sysctl.*permission denied.*src_valid_mark'; then
            bashio::log.warning 'sysctl permission denied - this is normal in Home Assistant containers. Checking if interface is up...'
            if ip link show "${wireguard_interface}" >/dev/null 2>&1; then
                bashio::log.info 'WireGuard interface is up despite sysctl error. Continuing.'
                status=0
                return 0
            fi
        fi

        # Handle resolvconf signature mismatch errors
        if echo "${output}" | grep -qi 'resolvconf.*signature mismatch'; then
            bashio::log.warning 'DNS signature mismatch detected, attempting to fix...'
            # Try to unlock and fix resolv.conf
            if lsof /etc/resolv.conf >/dev/null 2>&1; then
                bashio::log.info 'resolv.conf is locked by another process, using alternative DNS approach'
                # Skip DNS configuration in WireGuard and let add-on handle it
                sed -i '/^DNS/d' "${config_path}"
                bashio::log.info 'Removed DNS configuration from WireGuard config, will use add-on DNS settings'
            else
                # Force update resolv.conf
                echo "nameserver 1.1.1.1" > /etc/resolv.conf.new && mv /etc/resolv.conf.new /etc/resolv.conf
            fi
            # Retry the connection
            output="$(wg-quick up "${config_path}" 2>&1)" || status=$?
            if [ "${status}" -eq 0 ]; then return 0; fi
        fi

        # Check for iptables errors and try legacy fallback
        if echo "${output}" | grep -qiE 'iptables-restore|ip6tables-restore|xtables'; then
            bashio::log.warning 'iptables errors detected, trying fallbacks...'
            if command -v iptables-legacy >/dev/null 2>&1; then
                wg-quick down "${config_path}" >/dev/null 2>&1 || true
                _wg_prepare_legacy
                bashio::log.info 'Retrying with iptables-legacy...'
                output="$(wg-quick up "${config_path}" 2>&1)" || status=$?
                if [ "${status}" -eq 0 ]; then return 0; fi
            fi

            # If iptables still fails, try without firewall rules
            bashio::log.warning 'iptables-legacy also failed, trying without firewall rules...'
            wg-quick down "${config_path}" >/dev/null 2>&1 || true

            # Create a version without PostUp/PostDown/Table rules
            local no_fw_config="${WIREGUARD_STATE_DIR}/nofw.conf"
            grep -v -E '^(PostUp|PostDown|Table)' "${config_path}" > "${no_fw_config}"

            bashio::log.info 'Attempting WireGuard without firewall rules...'
            output="$(wg-quick up "${no_fw_config}" 2>&1)" || status=$?
            if [ "${status}" -eq 0 ]; then
                bashio::log.warning 'WireGuard connected without firewall rules. Traffic may not be properly routed.'
                return 0
            fi
        else
            bashio::log.warning 'iptables errors detected but iptables-legacy missing.'
            status=1
        fi
        return "${status}"
    }

    # 1. First Attempt
    bashio::log.info "Attempting to establish WireGuard connection..."
    if ! _wg_up_attempt "${wireguard_config}"; then
        bashio::log.warning 'Initial WireGuard connection failed. Trying IPv4-only endpoints.'
        bashio::log.debug "Output: ${output}"

        # 2. IPv4 Fallback Preparation
        local ipv4_config="${WIREGUARD_STATE_DIR}/ipv4.conf"
        : > "${ipv4_config}"
        chmod 600 "${ipv4_config}" 2>/dev/null || true

        local line endpoint endpoint_host endpoint_port
        while IFS= read -r line || [ -n "$line" ]; do
            if [[ "${line}" =~ ^Endpoint ]]; then
                endpoint="${line#Endpoint = }"
                endpoint_host="${endpoint%:*}"
                endpoint_port="${endpoint##*:}"

                # Resolve hostname to IPv4
                mapfile -t ipv4_candidates < <(getent ahostsv4 "${endpoint_host}" | awk '{print $1}' | uniq)

                if [ ${#ipv4_candidates[@]} -gt 0 ]; then
                    bashio::log.debug "Resolved ${endpoint_host} to ${ipv4_candidates[0]}"
                    echo "Endpoint = ${ipv4_candidates[0]}:${endpoint_port}" >> "${ipv4_config}"
                else
                    echo "${line}" >> "${ipv4_config}"
                fi
            else
                echo "${line}" >> "${ipv4_config}"
            fi
        done < "${wireguard_config}"

        wg-quick down "${wireguard_config}" >/dev/null 2>&1 || true

        # 3. Second Attempt (IPv4 only)
        if ! _wg_up_attempt "${ipv4_config}"; then
            bashio::log.warning 'IPv4-only attempt failed, trying container-friendly config...'
            bashio::log.debug "Output: ${output}"

            # Create a container-friendly config without complex routing
            local simple_config="${WIREGUARD_STATE_DIR}/simple.conf"
            : > "${simple_config}"
            chmod 600 "${simple_config}" 2>/dev/null || true

            # Copy config but remove problematic directives
            while IFS= read -r line || [ -n "$line" ]; do
                case "${line}" in
                    Table*|PostUp*|PostDown*|PreUp*|PreDown*)
                        # Skip routing table and script directives that cause issues in containers
                        bashio::log.debug "Skipping container-incompatible directive: ${line}"
                        ;;
                    *)
                        echo "${line}" >> "${simple_config}"
                        ;;
                esac
            done < "${ipv4_config}"

            wg-quick down "${ipv4_config}" >/dev/null 2>&1 || true

            # Final attempt with simplified config
            if ! _wg_up_attempt "${simple_config}"; then
                # Last resort: try manual interface creation without wg-quick
                bashio::log.warning 'wg-quick failed, trying manual WireGuard setup...'

                # Extract key values from config
                local private_key address endpoint public_key
                private_key=$(grep "^PrivateKey" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                address=$(grep "^Address" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                endpoint=$(grep "^Endpoint" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                public_key=$(grep "^PublicKey" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

                if [[ -n "${private_key}" && -n "${address}" && -n "${endpoint}" && -n "${public_key}" ]]; then
                    bashio::log.info "Attempting manual WireGuard setup..."
                    bashio::log.debug "Private key length: ${#private_key}"
                    bashio::log.debug "Address: ${address}"
                    bashio::log.debug "Endpoint: ${endpoint}"
                    bashio::log.debug "Public key length: ${#public_key}"

                    # Clean up any existing interface
                    ip link delete dev wg0 2>/dev/null || true

                    # Manual WireGuard setup without routing tables
                    if ip link add dev wg0 type wireguard && \
                       echo "${private_key}" | wg set wg0 private-key /dev/stdin && \
                       wg set wg0 peer "${public_key}" endpoint "${endpoint}" allowed-ips 0.0.0.0/0 && \
                       ip addr add "${address}" dev wg0 && \
                       ip link set wg0 up; then

                        bashio::log.info 'WireGuard interface created manually (basic connectivity)'
                        # Don't return here, let it continue to verification
                    else
                        bashio::log.error 'Manual WireGuard setup also failed'
                        bashio::log.error 'WireGuard failed to establish connection with all methods.'
                        bashio::log.error "${output}"
                        bashio::exit.nok 'WireGuard start failed.'
                    fi
                else
                    bashio::log.error 'Could not extract required WireGuard parameters'
                    bashio::log.error 'WireGuard failed to establish connection with all methods.'
                    bashio::log.error "${output}"
                    bashio::exit.nok 'WireGuard start failed.'
                fi
            else
                bashio::log.warning 'WireGuard connected with simplified container config.'
            fi
        fi
    fi

    bashio::log.info "WireGuard interface ${wireguard_interface} is up."

    # Verify the interface is actually working by checking if it has an IP
    interface_ip=$(ip addr show "${wireguard_interface}" 2>/dev/null | grep -oP 'inet \K[^/]+' | head -1 || true)

    if [[ -n "${interface_ip}" ]]; then
        bashio::log.info "WireGuard interface ${wireguard_interface} assigned IP: ${interface_ip}"
    else
        bashio::log.warning "WireGuard interface ${wireguard_interface} is up but no IP assigned"
    fi

    # Wait a moment for the connection to stabilize
    bashio::log.info "Waiting 10 seconds for WireGuard connection to stabilize..."
    sleep 10

    # DNS Refresh
    if command -v resolvconf >/dev/null 2>&1; then
        resolvconf -u >/dev/null 2>&1 || bashio::log.warning 'resolvconf -u failed.'
    fi
}

# --- Main Execution ---

openvpn_enabled=false
wireguard_enabled=false

if bashio::config.true 'openvpn_enabled'; then
    openvpn_enabled=true
fi

if bashio::config.true 'wireguard_enabled'; then
    wireguard_enabled=true
fi

if [[ "${openvpn_enabled}" == true && "${wireguard_enabled}" == true ]]; then
    bashio::log.error "Both OpenVPN and WireGuard are enabled. Only one VPN mode is supported."
    exit 1
fi

if [[ "${openvpn_enabled}" == true ]]; then

    exec /usr/sbin/openvpn \
        --config /config/openvpn/config.ovpn \
        --script-security 2 \
        --up /etc/openvpn/up.sh \
        --down /etc/openvpn/down.sh \
        --pull-filter ignore "route-ipv6" \
        --pull-filter ignore "ifconfig-ipv6" \
        --pull-filter ignore "tun-ipv6" \
        --pull-filter ignore "redirect-gateway ipv6" \
        --pull-filter ignore "dhcp-option DNS6" \
    &

elif [[ "${wireguard_enabled}" == true ]]; then

    # Run modularized WireGuard setup
    _setup_wireguard

    # Verify WireGuard is working before proceeding
    wg_interface="$(cat "/var/run/wireguard/interface" 2>/dev/null || echo 'wg0')"

    if ! ip link show "${wg_interface}" >/dev/null 2>&1; then
        bashio::exit.nok "WireGuard interface ${wg_interface} is not up. Check your configuration."
    fi

    bashio::log.info "WireGuard setup completed successfully."

fi

# --- Launch qBittorrent ---

# Determine log output based on silent mode
QB_OUTPUT="/dev/stdout"
if bashio::config.true 'silent'; then
    QB_OUTPUT="/dev/null"
fi

bashio::log.info "Starting qBittorrent..."

exec \
    s6-notifyoncheck -d -n 300 -w 1000 -c "nc -z localhost ${WEBUI_PORT}" \
    s6-setuidgid abc /usr/bin/qbittorrent-nox --webui-port="${WEBUI_PORT}" > "${QB_OUTPUT}"
