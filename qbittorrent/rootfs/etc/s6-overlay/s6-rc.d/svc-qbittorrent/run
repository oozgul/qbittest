#!/usr/bin/with-contenv bashio
# shellcheck shell=bash

WEBUI_PORT=${WEBUI_PORT:-8080}
export PATH="/usr/local/sbin:/usr/local/bin:${PATH}"

# --- Configuration & Pre-checks ---

if bashio::config.true 'silent'; then
    sed -i 's|/proc/1/fd/1 hassio;|off;|g' /etc/nginx/nginx.conf
fi

# --- WireGuard Specific Logic ---

_setup_wireguard() {
    local WIREGUARD_STATE_DIR="/var/run/wireguard"
    local output=""
    local status=0

    if ! bashio::fs.file_exists "${WIREGUARD_STATE_DIR}/config"; then
        bashio::exit.nok 'WireGuard runtime configuration not prepared. Please restart the add-on.'
    fi

    local wireguard_config
    wireguard_config="$(cat "${WIREGUARD_STATE_DIR}/config")"
    local wireguard_interface
    wireguard_interface="$(cat "${WIREGUARD_STATE_DIR}/interface" 2>/dev/null || echo 'wg0')"

    if ip link show "${wireguard_interface}" >/dev/null 2>&1; then
        bashio::log.warning "WireGuard interface ${wireguard_interface} already exists. Resetting."
        wg-quick down "${wireguard_config}" >/dev/null 2>&1 || true
    fi

    bashio::log.info "Starting WireGuard interface ${wireguard_interface}..."

    # Internal helper: fallback for iptables-legacy
    _wg_prepare_legacy() {
        local legacy_bin_dir="${WIREGUARD_STATE_DIR}/iptables-legacy-bin"
        mkdir -p "${legacy_bin_dir}"
        local cmd
        for cmd in iptables iptables-save iptables-restore ip6tables ip6tables-save ip6tables-restore; do
            if command -v "${cmd}-legacy" >/dev/null 2>&1; then
                ln -sf "$(command -v "${cmd}-legacy")" "${legacy_bin_dir}/${cmd}"
            fi
        done
        chmod 700 "${legacy_bin_dir}" 2>/dev/null || true
        export PATH="${legacy_bin_dir}:${PATH}"
        bashio::log.warning 'Retrying WireGuard using iptables-legacy wrappers.'
    }

    # Internal helper: Attempt connection
    _wg_up_attempt() {
        local config_path="$1"
        output="$(wg-quick up "${config_path}" 2>&1)" || status=$?

        if [ "${status}" -eq 0 ]; then return 0; fi

        # Allow sysctl failures on read-only hosts while keeping the interface up
        if echo "${output}" | grep -qi 'net\.ipv4\.conf\.all\.src_valid_mark=1'; then
            if echo "${output}" | grep -qiE 'read-only file system|operation not permitted|permission denied'; then
                if ip link show "${wireguard_interface}" >/dev/null 2>&1; then
                    bashio::log.warning 'WireGuard applied but sysctl net.ipv4.conf.all.src_valid_mark=1 could not be set (permission denied). Continuing.'
                    status=0
                    return 0
                fi
            fi
        fi

        # Handle sysctl permission denied errors specifically
        if echo "${output}" | grep -qi 'sysctl.*permission denied.*src_valid_mark'; then
            bashio::log.warning 'sysctl permission denied - this is normal in Home Assistant containers. Checking if interface is up...'
            if ip link show "${wireguard_interface}" >/dev/null 2>&1; then
                bashio::log.info 'WireGuard interface is up despite sysctl error. Continuing.'
                status=0
                return 0
            fi
        fi

        # Handle resolvconf signature mismatch errors
        if echo "${output}" | grep -qi 'resolvconf.*signature mismatch'; then
            bashio::log.warning 'DNS signature mismatch detected, attempting to fix...'
            # Try to unlock and fix resolv.conf
            if lsof /etc/resolv.conf >/dev/null 2>&1; then
                bashio::log.info 'resolv.conf is locked by another process, using alternative DNS approach'
                # Skip DNS configuration in WireGuard and let add-on handle it
                sed -i '/^DNS/d' "${config_path}"
                bashio::log.info 'Removed DNS configuration from WireGuard config, will use add-on DNS settings'
            else
                # Force update resolv.conf
                echo "nameserver 1.1.1.1" > /etc/resolv.conf.new && mv /etc/resolv.conf.new /etc/resolv.conf
            fi
            # Retry the connection
            output="$(wg-quick up "${config_path}" 2>&1)" || status=$?
            if [ "${status}" -eq 0 ]; then return 0; fi
        fi

        # Check for iptables errors and try legacy fallback
        if echo "${output}" | grep -qiE 'iptables-restore|ip6tables-restore|xtables'; then
            bashio::log.warning 'iptables errors detected, trying fallbacks...'
            if command -v iptables-legacy >/dev/null 2>&1; then
                wg-quick down "${config_path}" >/dev/null 2>&1 || true
                _wg_prepare_legacy
                bashio::log.info 'Retrying with iptables-legacy...'
                output="$(wg-quick up "${config_path}" 2>&1)" || status=$?
                if [ "${status}" -eq 0 ]; then return 0; fi
            fi

            # If iptables still fails, try without firewall rules
            bashio::log.warning 'iptables-legacy also failed, trying without firewall rules...'
            wg-quick down "${config_path}" >/dev/null 2>&1 || true

            # Create a version without PostUp/PostDown/Table rules
            local no_fw_config="${WIREGUARD_STATE_DIR}/nofw.conf"
            grep -v -E '^(PostUp|PostDown|Table)' "${config_path}" > "${no_fw_config}"

            bashio::log.info 'Attempting WireGuard without firewall rules...'
            output="$(wg-quick up "${no_fw_config}" 2>&1)" || status=$?
            if [ "${status}" -eq 0 ]; then
                bashio::log.warning 'WireGuard connected without firewall rules. Traffic may not be properly routed.'
                return 0
            fi
        else
            bashio::log.warning 'iptables errors detected but iptables-legacy missing.'
            status=1
        fi
        return "${status}"
    }

    # 1. First Attempt
    bashio::log.info "Attempting to establish WireGuard connection..."
    if ! _wg_up_attempt "${wireguard_config}"; then
        bashio::log.warning 'Initial WireGuard connection failed. Trying IPv4-only endpoints.'
        bashio::log.debug "Output: ${output}"

        # 2. IPv4 Fallback Preparation
        local ipv4_config="${WIREGUARD_STATE_DIR}/ipv4.conf"
        : > "${ipv4_config}"
        chmod 600 "${ipv4_config}" 2>/dev/null || true

        local line endpoint endpoint_host endpoint_port
        while IFS= read -r line || [ -n "$line" ]; do
            if [[ "${line}" =~ ^Endpoint ]]; then
                endpoint="${line#Endpoint = }"
                endpoint_host="${endpoint%:*}"
                endpoint_port="${endpoint##*:}"

                # Resolve hostname to IPv4
                mapfile -t ipv4_candidates < <(getent ahostsv4 "${endpoint_host}" | awk '{print $1}' | uniq)

                if [ ${#ipv4_candidates[@]} -gt 0 ]; then
                    bashio::log.debug "Resolved ${endpoint_host} to ${ipv4_candidates[0]}"
                    echo "Endpoint = ${ipv4_candidates[0]}:${endpoint_port}" >> "${ipv4_config}"
                else
                    echo "${line}" >> "${ipv4_config}"
                fi
            else
                echo "${line}" >> "${ipv4_config}"
            fi
        done < "${wireguard_config}"

        wg-quick down "${wireguard_config}" >/dev/null 2>&1 || true

        # 3. Second Attempt (IPv4 only)
        if ! _wg_up_attempt "${ipv4_config}"; then
            bashio::log.warning 'IPv4-only attempt failed, trying container-friendly config...'
            bashio::log.debug "Output: ${output}"

            # Create a container-friendly config without complex routing
            local simple_config="${WIREGUARD_STATE_DIR}/simple.conf"
            : > "${simple_config}"
            chmod 600 "${simple_config}" 2>/dev/null || true

            # Copy config but remove problematic directives
            while IFS= read -r line || [ -n "$line" ]; do
                case "${line}" in
                    Table*|PostUp*|PostDown*|PreUp*|PreDown*)
                        # Skip routing table and script directives that cause issues in containers
                        bashio::log.debug "Skipping container-incompatible directive: ${line}"
                        ;;
                    *)
                        echo "${line}" >> "${simple_config}"
                        ;;
                esac
            done < "${ipv4_config}"

            wg-quick down "${ipv4_config}" >/dev/null 2>&1 || true

            # Final attempt with simplified config
            if ! _wg_up_attempt "${simple_config}"; then
                # Last resort: try manual interface creation without wg-quick
                bashio::log.warning 'wg-quick failed, trying manual WireGuard setup...'

                # Extract key values from config
                local private_key address endpoint public_key
                private_key=$(grep "^PrivateKey" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                address=$(grep "^Address" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                endpoint=$(grep "^Endpoint" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                public_key=$(grep "^PublicKey" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

                if [[ -n "${private_key}" && -n "${address}" && -n "${endpoint}" && -n "${public_key}" ]]; then
                    bashio::log.info "Attempting manual WireGuard setup..."
                    bashio::log.debug "Private key length: ${#private_key}"
                    bashio::log.debug "Address: ${address}"
                    bashio::log.debug "Endpoint: ${endpoint}"
                    bashio::log.debug "Public key length: ${#public_key}"

                    # Clean up any existing interface thoroughly
                    if ip link show wg0 >/dev/null 2>&1; then
                        bashio::log.debug "Cleaning up existing wg0 interface"
                        ip link set wg0 down 2>/dev/null || true
                        ip link delete dev wg0 2>/dev/null || true
                        sleep 1
                    fi

                    # Manual WireGuard setup without routing tables
                    if ip link add dev wg0 type wireguard && \
                       echo "${private_key}" | wg set wg0 private-key /dev/stdin && \
                       wg set wg0 peer "${public_key}" endpoint "${endpoint}" allowed-ips 0.0.0.0/0 persistent-keepalive 25 && \
                       ip addr add "${address}" dev wg0 && \
                       ip link set mtu 1420 dev wg0 && \
                       ip link set wg0 up; then

                        bashio::log.info "WireGuard interface created successfully"

                        # Get default route info BEFORE modifying routing
                        default_gw=$(ip route show default | head -1 | awk '{print $3}')
                        default_dev=$(ip route show default | head -1 | awk '{print $5}')
                        vpn_endpoint_ip=$(echo "${endpoint}" | cut -d: -f1)

                        bashio::log.info "Network info - Gateway: ${default_gw:-none} Device: ${default_dev:-none} VPN Endpoint: ${vpn_endpoint_ip}"

                        # Test if endpoint is reachable BEFORE setting up routing
                        if [[ -n "${vpn_endpoint_ip}" ]]; then
                            bashio::log.info "Testing endpoint reachability..."
                            if ping -c 2 -W 3 "${vpn_endpoint_ip}" >/dev/null 2>&1; then
                                bashio::log.info "VPN endpoint ${vpn_endpoint_ip} is reachable"
                            else
                                bashio::log.warning "VPN endpoint ${vpn_endpoint_ip} is NOT reachable - handshake may fail"
                                bashio::log.info "Checking DNS resolution..."
                                endpoint_host=$(grep "^Endpoint" "${simple_config}" | cut -d= -f2- | sed 's/^[[:space:]]*//' | cut -d: -f1)
                                if [[ "${endpoint_host}" != "${vpn_endpoint_ip}" ]]; then
                                    bashio::log.info "Endpoint hostname: ${endpoint_host} resolved to: ${vpn_endpoint_ip}"
                                    # Try resolving again
                                    resolved_ip=$(getent ahostsv4 "${endpoint_host}" 2>/dev/null | awk 'NR==1{print $1}')
                                    if [[ -n "${resolved_ip}" && "${resolved_ip}" != "${vpn_endpoint_ip}" ]]; then
                                        bashio::log.warning "DNS resolution changed: ${endpoint_host} now resolves to ${resolved_ip}"
                                        vpn_endpoint_ip="${resolved_ip}"
                                    fi
                                fi
                            fi
                        fi

                        # CRITICAL FIX: Add endpoint route FIRST, before any default routes
                        # This ensures handshake packets can reach the VPN server
                        if [[ -n "${default_gw}" && -n "${vpn_endpoint_ip}" && -n "${default_dev}" ]]; then
                            if ip route add "${vpn_endpoint_ip}/32" via "${default_gw}" dev "${default_dev}" 2>/dev/null; then
                                bashio::log.info "Added route: VPN endpoint ${vpn_endpoint_ip} via ${default_gw}"
                            else
                                bashio::log.debug "Endpoint route already exists or failed to add"
                                # Check if route exists
                                if ip route get "${vpn_endpoint_ip}" 2>/dev/null | grep -q "${default_dev}"; then
                                    bashio::log.info "Endpoint route verified via ${default_dev}"
                                else
                                    bashio::log.error "Cannot route to VPN endpoint!"
                                fi
                            fi
                        else
                            bashio::log.error "Missing routing info - Gateway: ${default_gw:-MISSING} Endpoint: ${vpn_endpoint_ip:-MISSING} Device: ${default_dev:-MISSING}"
                        fi

                        # Wait a moment for endpoint route to settle
                        sleep 2

                        # Now add default routes through WireGuard (split routing to avoid conflicts)
                        if ip route add 0.0.0.0/1 dev wg0 2>/dev/null; then
                            bashio::log.info "Added route: 0.0.0.0/1 via wg0"
                        else
                            bashio::log.debug "Route 0.0.0.0/1 already exists"
                        fi

                        if ip route add 128.0.0.0/1 dev wg0 2>/dev/null; then
                            bashio::log.info "Added route: 128.0.0.0/1 via wg0"
                        else
                            bashio::log.debug "Route 128.0.0.0/1 already exists"
                        fi

                        bashio::log.info 'Routing configured - endpoint via gateway, all other traffic via wg0'

                        # Show current routing table
                        bashio::log.info "Current routing table:"
                        ip route show | head -20 | while read -r line; do bashio::log.info "  ${line}"; done

                        # Wait for WireGuard handshake to complete
                        bashio::log.info 'Waiting for WireGuard handshake (this may take 10-30 seconds)...'

                        handshake_success=false
                        for i in {1..6}; do
                            sleep 5
                            if wg show wg0 latest-handshakes 2>/dev/null | grep -v " 0$" >/dev/null 2>&1; then
                                bashio::log.info "WireGuard handshake successful after ${i}x5 seconds!"
                                handshake_success=true
                                break
                            else
                                bashio::log.debug "Handshake attempt ${i}/6 - waiting..."
                            fi
                        done

                        if [[ "${handshake_success}" == false ]]; then
                            bashio::log.warning 'No handshake detected after 30 seconds'
                            bashio::log.info 'WireGuard status:'
                            wg show wg0 2>/dev/null || bashio::log.error "Cannot query WireGuard status"
                        fi

                        # Try to generate some traffic to trigger server response
                        bashio::log.info 'Generating traffic to establish tunnel...'
                        curl --interface wg0 -m 5 -s http://icanhazip.com >/dev/null 2>&1 || true
                        sleep 2

                        # Test actual connectivity through the tunnel
                        bashio::log.info 'Testing tunnel connectivity...'

                        tunnel_working=false

                        # First try pinging the VPN gateway (usually .1 in the subnet)
                        vpn_gateway=$(echo "${address}" | cut -d/ -f1 | awk -F. '{print $1"."$2".0.1"}')
                        bashio::log.info "Testing VPN gateway: ${vpn_gateway}"
                        if ping -c 2 -W 3 "${vpn_gateway}" >/dev/null 2>&1; then
                            bashio::log.info "✓ VPN gateway ${vpn_gateway} is reachable!"
                            tunnel_working=true
                        else
                            bashio::log.debug "VPN gateway ${vpn_gateway} not responding (may not support ICMP)"
                        fi

                        # Try external DNS servers
                        bashio::log.info "Testing internet connectivity through tunnel..."
                        if ping -c 2 -W 5 1.1.1.1 >/dev/null 2>&1; then
                            bashio::log.info '✓ Internet reachable (1.1.1.1 responds)!'
                            tunnel_working=true
                        elif ping -c 2 -W 5 8.8.8.8 >/dev/null 2>&1; then
                            bashio::log.info '✓ Internet reachable (8.8.8.8 responds)!'
                            tunnel_working=true
                        elif ping -c 2 -W 5 1.0.0.1 >/dev/null 2>&1; then
                            bashio::log.info '✓ Internet reachable (1.0.0.1 responds)!'
                            tunnel_working=true
                        else
                            bashio::log.warning '✗ No ICMP responses from public DNS servers'
                        fi

                        if [[ "${tunnel_working}" == false ]]; then
                            bashio::log.warning 'Tunnel connectivity test inconclusive'

                            # Detailed diagnostics
                            bashio::log.info 'Diagnostics:'
                            bashio::log.info "  Interface state: $(ip link show wg0 2>/dev/null | grep -o 'state [A-Z]*' || echo 'UNKNOWN')"
                            bashio::log.info "  Interface IP: $(ip addr show wg0 2>/dev/null | grep -oP 'inet \K[^/]+' || echo 'NONE')"

                            # Check if endpoint is still reachable
                            if ping -c 1 -W 2 "${vpn_endpoint_ip}" >/dev/null 2>&1; then
                                bashio::log.info "  Endpoint reachable: YES"
                            else
                                bashio::log.error "  Endpoint reachable: NO - routing may be broken!"
                            fi

                            # Show WireGuard peer info and check for received data
                            bashio::log.info "  WireGuard peer status:"
                            wg show wg0 2>/dev/null | while read -r line; do bashio::log.info "    ${line}"; done || bashio::log.error "    Cannot show peer info"

                            # Check for received data
                            rx_bytes=$(wg show wg0 2>/dev/null | grep -oP 'transfer:.*?\K[0-9]+(?= B received)' | head -1)
                            if [[ "${rx_bytes}" == "0" || -z "${rx_bytes}" ]]; then
                                bashio::log.error "  ⚠ No data received from VPN server (0 bytes)"
                                bashio::log.error "  This usually means:"
                                bashio::log.error "    1. VPN server firewall is blocking return traffic"
                                bashio::log.error "    2. VPN server NAT/masquerading not configured"
                                bashio::log.error "    3. VPN server routing not set up correctly"
                                bashio::log.error "    4. Some VPN providers block ICMP - try testing with actual torrent traffic"
                            else
                                bashio::log.info "  ✓ Received ${rx_bytes} bytes from peer - tunnel may be working"
                                tunnel_working=true
                            fi

                            if [[ "${tunnel_working}" == false ]]; then
                                bashio::log.warning "Continuing anyway - some VPN providers block ICMP ping"
                                bashio::log.warning "qBittorrent will start and may work even if ping tests fail"
                                bashio::log.warning "Check qBittorrent logs and test with actual torrent downloads"
                            fi
                        else
                            bashio::log.info '✓ Tunnel connectivity verified!'
                        fi

                        # Check if this is ProtonVPN (has port forwarding)
                        if echo "${address}" | grep -q "^10\.2\."; then
                            bashio::log.info "ProtonVPN detected - attempting to configure port forwarding..."
                            vpn_gateway=$(echo "${address}" | cut -d/ -f1 | awk -F. '{print $1"."$2".0.1"}')

                            # Run port forwarding detection in background
                            chmod +x /usr/local/bin/protonvpn-portforward.sh 2>/dev/null || true
                            /usr/local/bin/protonvpn-portforward.sh "${vpn_gateway}" &
                        fi

                        # CRITICAL: Bind qBittorrent to wg0 interface
                        QBT_CONFIG_FILE="/config/qBittorrent/qBittorrent.conf"
                        if [ -f "${QBT_CONFIG_FILE}" ]; then
                            bashio::log.info "Binding qBittorrent to wg0 interface..."
                            sed -i '/Interface/d' "${QBT_CONFIG_FILE}"
                            sed -i "/\\[Preferences\\]/ i\\Connection\\\\Interface=wg0" "${QBT_CONFIG_FILE}"
                            sed -i "/\\[Preferences\\]/ i\\Connection\\\\InterfaceName=wg0" "${QBT_CONFIG_FILE}"
                            sed -i "/\\[BitTorrent\\]/a \\Session\\\\Interface=wg0" "${QBT_CONFIG_FILE}"
                            sed -i "/\\[BitTorrent\\]/a \\Session\\\\InterfaceName=wg0" "${QBT_CONFIG_FILE}"
                            bashio::log.info "qBittorrent bound to wg0 - will only use VPN"
                        else
                            bashio::log.warning "qBittorrent config not found - manual binding required"
                        fi

                        # Don't return here, let it continue to verification
                    else
                        bashio::log.error 'Manual WireGuard setup also failed'
                        bashio::log.error 'WireGuard failed to establish connection with all methods.'
                        bashio::log.error "${output}"
                        bashio::exit.nok 'WireGuard start failed.'
                    fi
                else
                    bashio::log.error 'Could not extract required WireGuard parameters'
                    bashio::log.error 'WireGuard failed to establish connection with all methods.'
                    bashio::log.error "${output}"
                    bashio::exit.nok 'WireGuard start failed.'
                fi
            else
                bashio::log.warning 'WireGuard connected with simplified container config.'
            fi
        fi
    fi

    bashio::log.info "WireGuard interface ${wireguard_interface} is up."

    # Verify the interface is actually working by checking if it has an IP
    interface_ip=$(ip addr show "${wireguard_interface}" 2>/dev/null | grep -oP 'inet \K[^/]+' | head -1 || true)

    if [[ -n "${interface_ip}" ]]; then
        bashio::log.info "WireGuard interface ${wireguard_interface} assigned IP: ${interface_ip}"
    else
        bashio::log.warning "WireGuard interface ${wireguard_interface} is up but no IP assigned"
    fi

    # Wait a moment for the connection to stabilize
    bashio::log.info "Waiting 10 seconds for WireGuard connection to stabilize..."
    sleep 10

    # DNS Refresh
    if command -v resolvconf >/dev/null 2>&1; then
        resolvconf -u >/dev/null 2>&1 || bashio::log.warning 'resolvconf -u failed.'
    fi
}

# --- Main Execution ---

openvpn_enabled=false
wireguard_enabled=false

if bashio::config.true 'openvpn_enabled'; then
    openvpn_enabled=true
fi

if bashio::config.true 'wireguard_enabled'; then
    wireguard_enabled=true
fi

if [[ "${openvpn_enabled}" == true && "${wireguard_enabled}" == true ]]; then
    bashio::log.error "Both OpenVPN and WireGuard are enabled. Only one VPN mode is supported."
    exit 1
fi

if [[ "${openvpn_enabled}" == true ]]; then

    exec /usr/sbin/openvpn \
        --config /config/openvpn/config.ovpn \
        --script-security 2 \
        --up /etc/openvpn/up.sh \
        --down /etc/openvpn/down.sh \
        --pull-filter ignore "route-ipv6" \
        --pull-filter ignore "ifconfig-ipv6" \
        --pull-filter ignore "tun-ipv6" \
        --pull-filter ignore "redirect-gateway ipv6" \
        --pull-filter ignore "dhcp-option DNS6" \
    &

elif [[ "${wireguard_enabled}" == true ]]; then

    # Run modularized WireGuard setup
    _setup_wireguard

    # Verify WireGuard is working before proceeding
    wg_interface="$(cat "/var/run/wireguard/interface" 2>/dev/null || echo 'wg0')"

    if ! ip link show "${wg_interface}" >/dev/null 2>&1; then
        bashio::exit.nok "WireGuard interface ${wg_interface} is not up. Check your configuration."
    fi

    bashio::log.info "WireGuard setup completed successfully."

fi

# --- Launch qBittorrent ---

# Determine log output based on silent mode
QB_OUTPUT="/dev/stdout"
if bashio::config.true 'silent'; then
    QB_OUTPUT="/dev/null"
fi

bashio::log.info "Starting qBittorrent..."

exec \
    s6-notifyoncheck -d -n 300 -w 1000 -c "nc -z localhost ${WEBUI_PORT}" \
    s6-setuidgid abc /usr/bin/qbittorrent-nox --webui-port="${WEBUI_PORT}" > "${QB_OUTPUT}"
